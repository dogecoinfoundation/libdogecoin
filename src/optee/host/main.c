/**
 * Copyright (c) 2024 edtubbs
 * Copyright (c) 2024 The Dogecoin Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <err.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ykpers-1/ykpers.h>
#include <ykpers-1/ykdef.h>
#include <unistd.h>
#include <getopt.h>

/* OP-TEE TEE client API (built by optee_client) */
#include <tee_client_api.h>

/* TA API: UUID and command IDs */
#include <libdogecoin_ta.h>

#include <libdogecoin.h>

#include <sys/time.h>

/* TEE resources */
struct test_ctx {
    TEEC_Context ctx;
    TEEC_Session sess;
};

void prepare_tee_session(struct test_ctx *ctx)
{
    TEEC_UUID uuid = TA_LIBDOGECOIN_UUID;
    uint32_t origin;
    TEEC_Result res;

    /* Initialize a context connecting us to the TEE */
    res = TEEC_InitializeContext(NULL, &ctx->ctx);
    if (res != TEEC_SUCCESS)
        errx(1, "TEEC_InitializeContext failed with code 0x%x", res);

    /* Open a session with the TA */
    res = TEEC_OpenSession(&ctx->ctx, &ctx->sess, &uuid,
                           TEEC_LOGIN_PUBLIC, NULL, NULL, &origin);
    if (res != TEEC_SUCCESS)
        errx(1, "TEEC_Opensession failed with code 0x%x origin 0x%x",
             res, origin);
}

void terminate_tee_session(struct test_ctx *ctx)
{
    TEEC_CloseSession(&ctx->sess);
    TEEC_FinalizeContext(&ctx->ctx);
}

TEEC_Result generate_seed(struct test_ctx *ctx)
{
    TEEC_Operation op;   /* Operation structure used for the RPC */
    uint32_t origin;     /* Origin of the command response */
    TEEC_Result res;     /* Return value of the TEE invocation */
    SEED seed;           /* Seed generated by the TA */

    /* Prepare the operation */
    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_OUTPUT,
                                     TEEC_NONE, TEEC_NONE, TEEC_NONE);
    op.params[0].tmpref.buffer = seed;
    op.params[0].tmpref.size = sizeof(seed);

    /* Invoke the command */
    res = TEEC_InvokeCommand(&ctx->sess,
                             TA_LIBDOGECOIN_CMD_GENERATE_SEED,
                             &op, &origin);

    /* Check the return value */
    if (res == TEEC_ERROR_SHORT_BUFFER) {
        /* Resize the buffer and retry */
        op.params[0].tmpref.buffer = malloc(op.params[0].tmpref.size);
        if (!op.params[0].tmpref.buffer)
            return TEEC_ERROR_OUT_OF_MEMORY;

        res = TEEC_InvokeCommand(&ctx->sess,
                                 TA_LIBDOGECOIN_CMD_GENERATE_SEED,
                                 &op, &origin);
        if (res == TEEC_SUCCESS) {
            /* Retrieve the output data */
            memcpy(seed, op.params[0].tmpref.buffer, sizeof(seed));
            printf("Seed generated: %s\n", utils_uint8_to_hex(seed, sizeof(seed)));
        } else {
            printf("Command GENERATE_SEED failed: 0x%x / %u\n", res, origin);
        }

        free(op.params[0].tmpref.buffer);
    } else if (res == TEEC_SUCCESS) {
        /* Retrieve the output data */
        memcpy(seed, op.params[0].tmpref.buffer, sizeof(seed));
        printf("Seed generated: %s\n", utils_uint8_to_hex(seed, sizeof(seed)));
    } else {
        printf("Command GENERATE_SEED failed: 0x%x / %u\n", res, origin);
    }

    return res;
}

TEEC_Result generate_master_key(struct test_ctx *ctx)
{
    TEEC_Operation op;  // Operation structure used for the RPC
    uint32_t origin;    // Origin of the command response
    TEEC_Result res;    // Return value of the TEE invocation
    char hd_master_privkey[HDKEYLEN];  // Master key generated by the TA

    // Prepare the operation
    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_OUTPUT,
                                     TEEC_NONE, TEEC_NONE, TEEC_NONE);
    op.params[0].tmpref.buffer = hd_master_privkey;
    op.params[0].tmpref.size = HDKEYLEN;

    // Invoke the command
    res = TEEC_InvokeCommand(&ctx->sess,
                             TA_LIBDOGECOIN_CMD_GENERATE_MASTERKEY,
                             &op, &origin);

    // Check the return value
    if (res == TEEC_ERROR_SHORT_BUFFER) {
        // Resize the buffer and retry
        op.params[0].tmpref.buffer = malloc(op.params[0].tmpref.size);
        if (!op.params[0].tmpref.buffer)
            return TEEC_ERROR_OUT_OF_MEMORY;

        res = TEEC_InvokeCommand(&ctx->sess,
                                 TA_LIBDOGECOIN_CMD_GENERATE_MASTERKEY,
                                 &op, &origin);
        if (res == TEEC_SUCCESS) {
            // Retrieve the output data
            memcpy(hd_master_privkey, op.params[0].tmpref.buffer, HDKEYLEN);
            printf("Master key generated: %s\n", hd_master_privkey);
        } else {
            printf("Command GENERATE_MASTERKEY failed: 0x%x / %u\n", res, origin);
        }

        free(op.params[0].tmpref.buffer);
    } else if (res == TEEC_SUCCESS) {
        // Retrieve the output data
        memcpy(hd_master_privkey, op.params[0].tmpref.buffer, HDKEYLEN);
        printf("Master key generated: %s\n", hd_master_privkey);
    } else {
        printf("Command GENERATE_MASTERKEY failed: 0x%x / %u\n", res, origin);
    }

    return res;
}

// Maximum size of managed credentials (shared secret, password, flags)
#define MAX_MANAGED_CREDS_SIZE  1024

TEEC_Result generate_mnemonic(struct test_ctx *ctx, const char *shared_secret, const char *password, const char* flags, const MNEMONIC mnemonic_in, const ENTROPY_SIZE entropy_size)
{
    TEEC_Operation op;  // Operation structure used for the RPC
    uint32_t origin;    // Origin of the command response
    TEEC_Result res;    // Return value of the TEE invocation
    MNEMONIC mnemonic = {0};  // Mnemonic generated by the TA
    char managed_creds[MAX_MANAGED_CREDS_SIZE] = {0}; // Buffer for managed credentials

    // Prepare the managed credentials as "<shared_secret>,<password>,<flags>"
    snprintf(managed_creds, sizeof(managed_creds), "%s,%s,%s",
             shared_secret ? shared_secret : "|",
             password ? password : "|",
             flags ? flags : "|");

    // Prepare the operation
    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_OUTPUT,
                                     TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_TEMP_INPUT);
    op.params[0].tmpref.buffer = mnemonic;
    op.params[0].tmpref.size = sizeof(mnemonic);
    op.params[1].tmpref.buffer = (void *)managed_creds;
    op.params[1].tmpref.size = strlen(managed_creds) + 1;  // Ensure null-terminator is included
    if (mnemonic_in) {
        op.params[2].tmpref.buffer = (void *)mnemonic_in;
        op.params[2].tmpref.size = strlen(mnemonic_in) + 1;  // Ensure null-terminator is included
    }
    if (entropy_size) {
        op.params[3].tmpref.buffer = (void *)entropy_size;
        op.params[3].tmpref.size = strlen(entropy_size) + 1;  // Ensure null-terminator is included
    }

    // Invoke the command
    res = TEEC_InvokeCommand(&ctx->sess,
                             TA_LIBDOGECOIN_CMD_GENERATE_MNEMONIC,
                             &op, &origin);

    // Check the return value
    if (res == TEEC_ERROR_SHORT_BUFFER) {
        // Resize the buffer and retry
        op.params[0].tmpref.buffer = malloc(op.params[0].tmpref.size);
        if (!op.params[0].tmpref.buffer)
            return TEEC_ERROR_OUT_OF_MEMORY;

        res = TEEC_InvokeCommand(&ctx->sess,
                                 TA_LIBDOGECOIN_CMD_GENERATE_MNEMONIC,
                                 &op, &origin);
        if (res == TEEC_SUCCESS) {
            // Retrieve the output data
            memcpy(mnemonic, op.params[0].tmpref.buffer, sizeof(mnemonic));
            printf("Mnemonic generated: %s\n", mnemonic);
        } else {
            printf("Command GENERATE_MNEMONIC failed: 0x%x / %u\n", res, origin);
        }

        free(op.params[0].tmpref.buffer);
    } else if (res == TEEC_SUCCESS) {
        // Retrieve the output data
        memcpy(mnemonic, op.params[0].tmpref.buffer, sizeof(mnemonic));
        printf("Mnemonic generated: %s\n", mnemonic);
    } else {
        printf("Command GENERATE_MNEMONIC failed: 0x%x / %u\n", res, origin);
    }

    // Erase the mnemonic and creds
    dogecoin_mem_zero(mnemonic, strlen(mnemonic));
    dogecoin_mem_zero(managed_creds, strlen(managed_creds));

    return res;
}

TEEC_Result generate_address_ta(struct test_ctx *ctx, const char* custom_path, const char* account, const char* address_index, const char* change_level, uint32_t auth_token, const char* password, char *address, size_t *address_len)
{
    TEEC_Operation op;
    uint32_t origin;
    TEEC_Result res;

    // Construct key path from account, change_level, and address_index
    char key_path[KEYPATHMAXLEN];
    snprintf(key_path, sizeof(key_path), "m/44'/3'/%s'/%s/%s", account, change_level, address_index);

    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_OUTPUT, TEEC_MEMREF_TEMP_INPUT, TEEC_VALUE_INPUT, TEEC_MEMREF_TEMP_INPUT);

    op.params[0].tmpref.buffer = address;
    op.params[0].tmpref.size = *address_len;
    op.params[1].tmpref.buffer = (void *)((custom_path != NULL) ? custom_path : key_path);
    op.params[1].tmpref.size = strlen(op.params[1].tmpref.buffer) + 1;
    op.params[2].value.a = auth_token;
    op.params[3].tmpref.buffer = (void *)password;
    op.params[3].tmpref.size = password ? strlen(password) + 1 : 0;

    res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_GENERATE_ADDRESS, &op, &origin);

    if (res == TEEC_ERROR_SHORT_BUFFER) {
        *address_len = op.params[0].tmpref.size;
        op.params[0].tmpref.buffer = malloc(*address_len);
        if (!op.params[0].tmpref.buffer)
            return TEEC_ERROR_OUT_OF_MEMORY;

        res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_GENERATE_ADDRESS, &op, &origin);
        if (res == TEEC_SUCCESS) {
            *address_len = op.params[0].tmpref.size;
            memcpy(address, op.params[0].tmpref.buffer, *address_len);
        } else {
            printf("Command GENERATE_ADDRESS failed: 0x%x / %u\n", res, origin);
        }

        free(op.params[0].tmpref.buffer);
    } else if (res == TEEC_SUCCESS) {
        *address_len = op.params[0].tmpref.size;
    } else {
        printf("Command GENERATE_ADDRESS failed: 0x%x / %u\n", res, origin);
    }

    return res;
}

TEEC_Result generate_extended_public_key_ta(struct test_ctx *ctx, const char* custom_path, const char* account, const char* change_level, uint32_t auth_token, const char* password, char *pubkey, size_t *pubkey_len)
{
    TEEC_Operation op;
    uint32_t origin;
    TEEC_Result res;

    // Construct key path from account and change_level
    char key_path[KEYPATHMAXLEN];
    snprintf(key_path, sizeof(key_path), "m/44'/3'/%s'/%s", account, change_level);

    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_OUTPUT, TEEC_MEMREF_TEMP_INPUT, TEEC_VALUE_INPUT, TEEC_MEMREF_TEMP_INPUT);

    op.params[0].tmpref.buffer = pubkey;
    op.params[0].tmpref.size = *pubkey_len;
    op.params[1].tmpref.buffer = (void *)((custom_path != NULL) ? custom_path : key_path);
    op.params[1].tmpref.size = strlen(op.params[1].tmpref.buffer) + 1;
    op.params[2].value.a = auth_token;
    op.params[3].tmpref.buffer = (void *)password;
    op.params[3].tmpref.size = password ? strlen(password) + 1 : 0;

    res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_GENERATE_EXTENDED_PUBLIC_KEY, &op, &origin);

    if (res == TEEC_ERROR_SHORT_BUFFER) {
        *pubkey_len = op.params[0].tmpref.size;
        op.params[0].tmpref.buffer = malloc(*pubkey_len);
        if (!op.params[0].tmpref.buffer)
            return TEEC_ERROR_OUT_OF_MEMORY;

        res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_GENERATE_EXTENDED_PUBLIC_KEY, &op, &origin);
        if (res == TEEC_SUCCESS) {
            *pubkey_len = op.params[0].tmpref.size;
            memcpy(pubkey, op.params[0].tmpref.buffer, *pubkey_len);
        } else {
            printf("Command GENERATE_EXTENDED_PUBLIC_KEY failed: 0x%x / %u\n", res, origin);
        }

        free(op.params[0].tmpref.buffer);
    } else if (res == TEEC_SUCCESS) {
        *pubkey_len = op.params[0].tmpref.size;
    } else {
        printf("Command GENERATE_EXTENDED_PUBLIC_KEY failed: 0x%x / %u\n", res, origin);
    }

    return res;
}

TEEC_Result sign_message_ta(struct test_ctx *ctx, const char* custom_path, const char* account, const char* address_index, const char* change_level, uint32_t auth_token, const char* password, char *message, char *signature, size_t *signature_len)
{
    TEEC_Operation op;
    uint32_t origin;
    TEEC_Result res;

    // Construct key path from account, change_level, and address_index
    char key_path[KEYPATHMAXLEN];
    if (custom_path && strlen(custom_path) > 0) {
        snprintf(key_path, sizeof(key_path), "%s,%s", custom_path, password);
    } else {
        snprintf(key_path, sizeof(key_path), "m/44'/3'/%s'/%s/%s,%s", account, change_level, address_index, password);
    }

    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
                                     TEEC_MEMREF_TEMP_OUTPUT,
                                     TEEC_MEMREF_TEMP_INPUT, TEEC_VALUE_INPUT);

    op.params[0].tmpref.buffer = message;
    op.params[0].tmpref.size = message ? strlen(message) + 1 : 0;  // Ensure null-terminator is included
    op.params[1].tmpref.buffer = signature;
    op.params[1].tmpref.size = *signature_len;
    op.params[2].tmpref.buffer = key_path;
    op.params[2].tmpref.size = strlen(key_path) + 1;
    op.params[3].value.a = auth_token;
    op.params[3].value.b = password ? strlen(password) + 1 : 0;

    res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_SIGN_MESSAGE, &op, &origin);

    if (res == TEEC_ERROR_SHORT_BUFFER) {
        // Resize the buffer and retry
        *signature_len = op.params[1].tmpref.size;
        op.params[1].tmpref.buffer = malloc(*signature_len);
        if (!op.params[1].tmpref.buffer)
            return TEEC_ERROR_OUT_OF_MEMORY;

        res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_SIGN_MESSAGE, &op, &origin);
        if (res == TEEC_SUCCESS) {
            *signature_len = op.params[1].tmpref.size;
            memcpy(signature, op.params[1].tmpref.buffer, *signature_len);
        } else {
            printf("Command SIGN_MESSAGE failed: 0x%x / %u\n", res, origin);
        }

        free(op.params[1].tmpref.buffer);
    } else if (res == TEEC_SUCCESS) {
        *signature_len = op.params[1].tmpref.size;
    } else {
        printf("Command SIGN_MESSAGE failed: 0x%x / %u\n", res, origin);
    }

    return res;
}

TEEC_Result sign_transaction_ta(struct test_ctx *ctx, const char* custom_path, const char* account, const char* address_index, const char* change_level, uint32_t auth_token, const char* password, char *raw_tx, size_t raw_tx_len, char *signed_tx, size_t *signed_tx_len)
{
    TEEC_Operation op;
    uint32_t origin;
    TEEC_Result res;

    // Construct key path from account, change_level, and address_index
    char key_path[KEYPATHMAXLEN];
    if (custom_path && strlen(custom_path) > 0) {
        snprintf(key_path, sizeof(key_path), "%s,%s", custom_path, password);
    } else {
        snprintf(key_path, sizeof(key_path), "m/44'/3'/%s'/%s/%s,%s", account, change_level, address_index, password);
    }

    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,
                                     TEEC_MEMREF_TEMP_OUTPUT,
                                     TEEC_MEMREF_TEMP_INPUT, TEEC_VALUE_INPUT);

    op.params[0].tmpref.buffer = raw_tx;
    op.params[0].tmpref.size = raw_tx_len;
    op.params[1].tmpref.buffer = signed_tx;
    op.params[1].tmpref.size = *signed_tx_len;
    op.params[2].tmpref.buffer = key_path;
    op.params[2].tmpref.size = strlen(key_path) + 1;
    op.params[3].value.a = auth_token;
    op.params[3].value.b = password ? strlen(password) + 1 : 0;

    res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_SIGN_TRANSACTION, &op, &origin);

    if (res == TEEC_ERROR_SHORT_BUFFER) {
        // Resize the buffer and retry
        *signed_tx_len = op.params[1].tmpref.size;
        op.params[1].tmpref.buffer = malloc(*signed_tx_len);
        if (!op.params[1].tmpref.buffer)
            return TEEC_ERROR_OUT_OF_MEMORY;

        res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_SIGN_TRANSACTION, &op, &origin);
        if (res == TEEC_SUCCESS) {
            *signed_tx_len = op.params[1].tmpref.size;
            memcpy(signed_tx, op.params[1].tmpref.buffer, *signed_tx_len);
        } else {
            printf("Command SIGN_TRANSACTION failed: 0x%x / %u\n", res, origin);
        }

        free(op.params[1].tmpref.buffer);
    } else if (res == TEEC_SUCCESS) {
        *signed_tx_len = op.params[1].tmpref.size;
    } else {
        printf("Command SIGN_TRANSACTION failed: 0x%x / %u\n", res, origin);
    }

    return res;
}

TEEC_Result delegate_key_ta(struct test_ctx *ctx, const char* custom_path, const char* account, uint32_t auth_token, const char* delegate_password, const char *password, char *delegate_key)
{
    TEEC_Operation op;
    uint32_t origin;
    TEEC_Result res;

    char delegate_creds[MAX_MANAGED_CREDS_SIZE] = {0}; // Buffer for delegated credentials

    // Prepare the delegated credentials as "<delegate_password>,<password>"
    snprintf(delegate_creds, sizeof(delegate_creds), "%s,%s",
        delegate_password && strlen(delegate_password) > 0 ? delegate_password : "none",
        password && strlen(password) > 0 ? password : "none");

    // Construct key path from account, change_level, and address_index
    char key_path[KEYPATHMAXLEN];
    snprintf(key_path, sizeof(key_path), "m/44'/3'/%s'", account);

    // Prepare the operation
    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_OUTPUT, TEEC_MEMREF_TEMP_INPUT, TEEC_VALUE_INPUT, TEEC_MEMREF_TEMP_INPUT);

    op.params[0].tmpref.buffer = delegate_key;
    op.params[0].tmpref.size = HDKEYLEN;
    op.params[1].tmpref.buffer = (void *)((custom_path != NULL) ? custom_path : key_path);
    op.params[1].tmpref.size = strlen(op.params[1].tmpref.buffer) + 1;
    op.params[2].value.a = auth_token;
    op.params[3].tmpref.buffer = (void *)delegate_creds;
    op.params[3].tmpref.size = strlen(delegate_creds) + 1;

    // Invoke the command
    res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_DELEGATE_KEY, &op, &origin);

    if (res != TEEC_SUCCESS) {
        printf("Command DELEGATE_KEY failed: 0x%x / %u\n", res, origin);
    }

    // Erase the creds
    dogecoin_mem_zero(delegate_creds, strlen(delegate_creds));

    return res;
}

TEEC_Result export_delegate_key_ta(struct test_ctx *ctx, const char* custom_path, const char* account, const char *password, char *exported_key) {
    TEEC_Operation op;
    uint32_t origin;
    TEEC_Result res;

    // Prepare the operation
    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_OUTPUT, TEEC_MEMREF_TEMP_INPUT, TEEC_NONE, TEEC_MEMREF_TEMP_INPUT);

    // Construct key path from account, change_level, and address_index
    char key_path[KEYPATHMAXLEN];
    snprintf(key_path, sizeof(key_path), "m/44'/3'/%s'", account);

    op.params[0].tmpref.buffer = exported_key;
    op.params[0].tmpref.size = HDKEYLEN;
    op.params[1].tmpref.buffer = (void *)((custom_path != NULL) ? custom_path : key_path);
    op.params[1].tmpref.size = strlen(op.params[1].tmpref.buffer) + 1;
    op.params[3].tmpref.buffer = (void *)password;
    op.params[3].tmpref.size = password ? strlen(password) + 1 : 0;

    // Invoke the command
    res = TEEC_InvokeCommand(&ctx->sess, TA_LIBDOGECOIN_CMD_EXPORT_DELEGATED_KEY, &op, &origin);

    if (res != TEEC_SUCCESS) {
        printf("Command EXPORT_DELEGATED_KEY failed: 0x%x / %u\n", res, origin);
    }

    return res;
}

#define TOTP_SECRET_HEX_SIZE    41 // hex, 40 characters + null

static struct option long_options[] = {
    {"command", required_argument, NULL, 'c'},
    {"account", required_argument, NULL, 'o'},
    {"change_level", required_argument, NULL, 'l'},
    {"address_index", required_argument, NULL, 'i'},
    {"message", required_argument, NULL, 'm'},
    {"transaction", required_argument, NULL, 't'},
    {"mnemonic_input", required_argument, NULL, 'n'},
    {"shared_secret", required_argument, NULL, 's'},
    {"entropy_size", required_argument, NULL, 'e'},
    {"password", required_argument, NULL, 'p'},
    {"delegate_password", required_argument, NULL, 'd'},
    {"auth_token", required_argument, NULL, 'a'},
    {"flags", required_argument, NULL, 'f'},
    {"custom_path", required_argument, NULL, 'h'},
    {"yubikey", no_argument, NULL, 'z'},
    {NULL, 0, NULL, 0}
};

static void print_usage()
{
    printf("Usage: optee_libdogecoin -c <cmd> (-o|-account_int <account_int>) (-i|-input_index <input index>) (-l|-change_level <change level>) \
(-m|-message <message>) (-t|-transaction <transaction>) (-n|-mnemonic_input <mnemonic input>) (-s|-shared_secret <shared secret>) \
(-e|-entropy_size <entropy size>) (-a|-auth_token <auth token>) (-p|-password <password>) (-d|-delegate_password <delegate password>) \
(-h|custom_path <custom_path>) (-f|flags <flags>) (-z|yubikey)\n");
    printf("Available commands:\n");
    printf("  generate_mnemonic (optional -n <mnemonic_input> -s <shared_secret> -e <entropy_size> -p <password> -f <flags>)\n");
    printf("  generate_extended_public_key (requires -o <account> -l <change_level>, optional -h <custom_path> -a <auth_token> -p <password> -z)\n");
    printf("  generate_address (requires -o <account> -l <change_level> -i <address_index>, optional -h <custom_path> -a <auth_token> -p <password> -z)\n");
    printf("  sign_message (requires -o <account> -l <change_level> -i <address_index> -m <message>, optional -h <custom_path> -a <auth_token> -p <password> -z)\n");
    printf("  sign_transaction (requires -o <account> -l <change_level> -i <address_index> -t <transaction>, optional -h <custom_path> -a <auth_token> -p <password> -z)\n");
    printf("  delegate_key (requires -o <account> -d <delegate_password>, optional -h <custom_path> -a <auth_token> -p <password> -z)\n");
    printf("  export_delegate_key (requires -o <account> -d <delegate_password>, optional -h <custom_path>)\n");
}

#define TIME_STEP 30

void set_totp_secret(YK_KEY *yk, const char *secret, const uint8_t slot) {
    YKP_CONFIG *cfg = ykp_alloc();
    YK_STATUS *st = ykds_alloc();

    if (!cfg || !st) {
        fprintf(stderr, "Failed to allocate YubiKey structures\n");
        ykp_free_config(cfg);
        ykds_free(st);
        return;
    }

    if (!yk_get_status(yk, st)) {
        fprintf(stderr, "Failed to get YubiKey status: %s\n", yk_strerror(yk_errno));
        ykp_free_config(cfg);
        ykds_free(st);
        return;
    }

    ykp_configure_version(cfg, st);

    // Set flags for HMAC challenge-response
    struct config_st *core_config = (struct config_st *) ykp_core_config(cfg);
    core_config->tktFlags |= TKTFLAG_CHAL_RESP;
    core_config->cfgFlags |= CFGFLAG_CHAL_HMAC;
    core_config->cfgFlags |= CFGFLAG_HMAC_LT64;
    core_config->cfgFlags &= ~CFGFLAG_CHAL_BTN_TRIG; // Disable button press
    core_config->extFlags |= EXTFLAG_SERIAL_API_VISIBLE;

    if (!ykp_configure_command(cfg, slot)) {
        fprintf(stderr, "Internal error: couldn't configure command\n");
        ykp_free_config(cfg);
        ykds_free(st);
        return;
    }

    printf("Configuring shared secret...\n");

    // Ensure the secret size is correct
    if (sizeof(secret) > TOTP_SECRET_HEX_SIZE) {
        fprintf(stderr, "Secret too long\n");
        ykp_free_config(cfg);
        ykds_free(st);
        return;
    }

    if (ykp_HMAC_key_from_hex(cfg, secret) != 0) {
        fprintf(stderr, "Internal error: couldn't configure key\n");
        ykp_free_config(cfg);
        ykds_free(st);
        return;
    }

    // Write to YubiKey
    printf("Writing configuration to YubiKey...\n");
    if (!yk_write_command(yk, ykp_core_config(cfg), ykp_command(cfg), NULL)) {
        fprintf(stderr, "Failed to write command: %s\n", yk_strerror(yk_errno));
        ykp_free_config(cfg);
        ykds_free(st);
        return;
    }

    printf("Shared secret set successfully\n");

    ykp_free_config(cfg);
    ykds_free(st);
}

uint32_t get_totp_from_yubikey(YK_KEY *yk, uint8_t yk_cmd) {
    unsigned int t_counter = (unsigned int)time(NULL) / 30;
    unsigned char challenge[8];
    for (int i = 7; i >= 0; i--) {
        challenge[i] = t_counter & 0xFF;
        t_counter >>= 8;
    }

    if (!yk) {
        fprintf(stderr, "Failed to get yubikey\n");
        return 0;
    }

    unsigned char response[SHA1_MAX_BLOCK_SIZE];
    if (!yk_challenge_response(yk, yk_cmd, true, sizeof(challenge), challenge, sizeof(response), response)) {
        fprintf(stderr, "Failed to generate TOTP code\n");
        return 0;
    }

    unsigned int offset = response[19] & 0xf;
    unsigned int bin_code = (response[offset] & 0x7f) << 24 |
                            (response[offset + 1] & 0xff) << 16 |
                            (response[offset + 2] & 0xff) << 8 |
                            (response[offset + 3] & 0xff);

    return bin_code % 1000000;
}

int main(int argc, const char* argv[])
{
    struct test_ctx ctx;
    int opt = 0;
    int long_index = 0;
    char* cmd = 0;
    uint32_t auth_token = 0;
    const char* custom_path = NULL;
    const char* account = NULL;
    const char* address_index = NULL;
    const char* change_level = NULL;
    char* message = NULL;
    char* transaction = NULL;
    uint8_t* shared_secret = NULL;
    char* password = NULL;
    char* mnemonic = NULL;
    char* entropy_size = NULL;
    char* delegate_password = NULL;
    dogecoin_bool yubikey = false;
    char* flags = "";

    while ((opt = getopt_long_only(argc, argv, "c:o:l:i:m:t:n:s:e:p:d:a:f:h:z", long_options, &long_index)) != -1) {
        switch (opt) {
            case 'c':
                cmd = optarg;
                break;
            case 'o':
                account = optarg;
                break;
            case 'i':
                address_index = optarg;
                break;
            case 'l':
                change_level = optarg;
                break;
            case 'm':
                message = optarg;
                break;
            case 't':
                transaction = optarg;
                break;
            case 'n':
                mnemonic = optarg;
                break;
            case 's':
                shared_secret = optarg;
                break;
            case 'p':
                password = optarg;
                break;
            case 'd':
                delegate_password = optarg;
                break;
            case 'e':
                entropy_size = optarg;
                break;
            case 'a':
                auth_token = (uint32_t)strtol(optarg, NULL, 10);
                break;
            case 'f':
                flags = optarg;
                break;
            case 'h':
                custom_path = optarg;
                break;
            case 'z':
                yubikey = true;
                break;
            default:
                print_usage();
                exit(EXIT_SUCCESS);
        }
    }

    if (!cmd) {
        /* exit if no command was provided */
        print_usage();
        exit(EXIT_SUCCESS);
    }

    printf("Prepare session with the TA\n");
    prepare_tee_session(&ctx);

    YK_KEY *yk = NULL;
    if (!yk_init() && yubikey) {
        fprintf(stderr, "Failed to initialize YubiKey\n");
    } else if (yubikey) {
        yk = yk_open_first_key();
        if (!yk) {
            fprintf(stderr, "Failed to open YubiKey\n");
        }
    }

    if (strcmp(cmd, "generate_seed") == 0) {
        printf("- Generate a seed\n");
        TEEC_Result res = generate_seed(&ctx);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to generate a seed");
        else
            printf("Seed generated\n");
    } else if (strcmp(cmd, "generate_master_key") == 0) {
        printf("- Generate a master key\n");
        TEEC_Result res = generate_master_key(&ctx);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to generate a master key");
        else
            printf("Master key generated\n");
    } else if (strcmp(cmd, "generate_mnemonic") == 0) {
        printf("- Generate and encrypt a mnemonic\n");

        if (yubikey) {
            if (!shared_secret) {
                shared_secret = getpass("Enter shared secret for TOTP (hex, 40 characters) or press enter to generate one: ");
                if (!shared_secret) {
                    fprintf(stderr, "Failed to read shared secret\n");
                 goto exit;
                }
            }

            if (strlen(shared_secret) == 0) {
                printf("Shared secret not provided, generating one...\n");
                // Generate random 20 bytes (40 hex characters)
                unsigned char random_bytes[TOTP_SECRET_HEX_SIZE / 2];
                dogecoin_random_bytes(random_bytes, sizeof(random_bytes), 0);

                shared_secret = malloc(TOTP_SECRET_HEX_SIZE + 1);
                if (!shared_secret) {
                    fprintf(stderr, "Failed to allocate memory for shared secret\n");
                    goto exit;
                }

                utils_bin_to_hex(random_bytes, sizeof(random_bytes), shared_secret);
                shared_secret[TOTP_SECRET_HEX_SIZE] = '\0';
                printf("Generated shared secret: %s\n", shared_secret);
            }

            // Check if there is an existing configuration in slot 1
            YK_STATUS *status = ykds_alloc();
            if (yk) {
                if (!yk_get_status(yk, status)) {
                    fprintf(stderr, "Failed to get YubiKey status\n");
                }
            }

            // Check if slot 1 has a configuration
            if (yk && (ykds_touch_level(status) & CONFIG1_VALID) == CONFIG1_VALID) {
                char response;
                printf("Slot 1 already has a configuration. Do you want to overwrite it? (y/N): ");
                scanf(" %c", &response);
                if (response != 'y' && response != 'Y') {
                    printf("Aborted by user\n");
                    ykds_free(status);
                    goto exit;
                }
            }

            ykds_free(status);

            if (yk) {
                set_totp_secret(yk, shared_secret, SLOT_CONFIG);
            }
        }

        if (!password && !shared_secret) {
            password = getpass("Enter management password: ");
            if (strlen(password) == 0) {
                fprintf(stderr, "Password cannot be empty\n");
                goto exit;
            }
            printf("\n");
            if (strcmp (password, getpass("Confirm password: ")) != 0) {
                fprintf(stderr, "Password mismatch\n");
                goto exit;
            }
            printf("\n");
        }

        TEEC_Result res = generate_mnemonic(&ctx, shared_secret, password, flags, mnemonic, entropy_size);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to generate a mnemonic");
    } else if (strcmp(cmd, "generate_address") == 0) {
        printf("- Generate an address\n");
        char address[35];
        size_t address_len = sizeof(address);

        if (!password && !yubikey && auth_token == 0) {
            password = getpass("Enter management password: ");
            if (!password) {
                fprintf(stderr, "Failed to read password\n");
                goto exit;
            }
        }

        if (auth_token == 0 && yubikey) {
            auth_token = get_totp_from_yubikey(yk, SLOT_CHAL_HMAC1);
        }
        printf("Auth token: %u\n", auth_token);

        TEEC_Result res = generate_address_ta(&ctx, custom_path, account, address_index, change_level, auth_token, password, address, &address_len);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to generate address");
        else
            printf("Address generated: %s\n", address);
    } else if (strcmp(cmd, "generate_extended_public_key") == 0) {
        printf("- Generate a public extended key\n");
        char pubkey[HDKEYLEN];
        size_t pubkey_len = sizeof(pubkey);

        if (!password && !yubikey && auth_token == 0) {
            password = getpass("Enter management password: ");
            if (!password) {
                fprintf(stderr, "Failed to read password\n");
                goto exit;
            }
        }

        if (auth_token == 0 && yubikey) {
            auth_token = get_totp_from_yubikey(yk, SLOT_CHAL_HMAC1);
        }
        printf("Auth token: %u\n", auth_token);

        TEEC_Result res = generate_extended_public_key_ta(&ctx, custom_path, account, change_level, auth_token, password, pubkey, &pubkey_len);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to generate public extended key");
        else
            printf("Public extended key generated: %s\n", pubkey);
    } else if (strcmp(cmd, "sign_message") == 0) {
        printf("- Sign a message\n");
        char signature[2048] = {0};
        size_t signature_len = sizeof(signature);

        if (!password && !yubikey && auth_token == 0) {
            password = getpass("Enter management password: ");
            if (!password) {
                fprintf(stderr, "Failed to read password\n");
                goto exit;
            }
        }

        if (auth_token == 0 && yubikey) {
            auth_token = get_totp_from_yubikey(yk, SLOT_CHAL_HMAC1);
        }
        printf("Auth token: %u\n", auth_token);

        TEEC_Result res = sign_message_ta(&ctx, custom_path, account, address_index, change_level, auth_token, password, message ? message : "This is a test message", signature, &signature_len);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to sign the message");
        else
            printf("Message signed: %s\n", signature);
    } else if (strcmp(cmd, "sign_transaction") == 0) {
        printf("- Sign a transaction\n");
        char raw_tx[1024];
        char signed_tx[4096];
        size_t signed_tx_len = sizeof(signed_tx);

        // Example transaction creation process
        char *external_p2pkh_addr = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";
        char *hash_2_doge = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074";
        char *hash_10_doge = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2";

        int idx = start_transaction();
        printf("Empty transaction created at index %d.\n", idx);

        if (add_utxo(idx, hash_2_doge, 1)) {
            printf("Input of value 2 dogecoin added to the transaction.\n");
        } else {
            printf("Error occurred while adding input of value 2 dogecoin.\n");
            return TEEC_ERROR_GENERIC;
        }

        if (add_utxo(idx, hash_10_doge, 1)) {
            printf("Input of value 10 dogecoin added to the transaction.\n");
        } else {
            printf("Error occurred while adding input of value 10 dogecoin.\n");
            return TEEC_ERROR_GENERIC;
        }

        if (add_output(idx, external_p2pkh_addr, "5.0")) {
            printf("Output of value 5 dogecoin added to the transaction.\n");
        } else {
            printf("Error occurred while adding output of value 5 dogecoin.\n");
            return TEEC_ERROR_GENERIC;
        }

        int idx2 = store_raw_transaction(finalize_transaction(idx, external_p2pkh_addr, "0.00226", "12", "D5AkTLEwB4eCNcFoZN9pj1TxgkhQiVzt3T"));
        if (idx2 > 0) {
            printf("Change returned to address %s and finalized unsigned transaction saved at index %d.\n", "D5AkTLEwB4eCNcFoZN9pj1TxgkhQiVzt3T", idx2);
        } else {
            printf("Error occurred while storing finalized unsigned transaction.\n");
            return TEEC_ERROR_GENERIC;
        }

        const char* raw_tx_hex = get_raw_transaction(idx);
        strncpy(raw_tx, raw_tx_hex, sizeof(raw_tx) - 1);
        raw_tx[sizeof(raw_tx) - 1] = '\0';
        printf("Raw transaction created: %s\n", raw_tx);
        printf("Raw transaction length: %zu\n", strlen(raw_tx));

        if (!password && !yubikey && auth_token == 0) {
            password = getpass("Enter management password: ");
            if (!password) {
                fprintf(stderr, "Failed to read password\n");
                goto exit;
            }
        }

        if (auth_token == 0 && yubikey) {
            auth_token = get_totp_from_yubikey(yk, SLOT_CHAL_HMAC1);
        }
        printf("Auth token: %u\n", auth_token);

        TEEC_Result res = sign_transaction_ta(&ctx, custom_path, account, address_index, change_level, auth_token, password, (transaction != NULL) ? transaction : raw_tx, strlen((transaction != NULL) ? transaction : raw_tx) + 1, signed_tx, &signed_tx_len);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to sign the transaction");
        else
            printf("Transaction signed: %s\n", signed_tx);
    } else if (strcmp(cmd, "delegate_key") == 0) {
        printf("- Delegate a key\n");
        char delegate_key[HDKEYLEN];

        if (!delegate_password) {
            delegate_password = getpass("Enter delegate password: ");
            if (!delegate_password) {
                fprintf(stderr, "Failed to read delegate password\n");
                goto exit;
            }
        }

        if (!password && !yubikey && auth_token == 0) {
            password = getpass("Enter management password: ");
            if (!password) {
                fprintf(stderr, "Failed to read password\n");
                goto exit;
            }
        }

        if (auth_token == 0 && yubikey) {
            auth_token = get_totp_from_yubikey(yk, SLOT_CHAL_HMAC1);
        }
        printf("Auth token: %u\n", auth_token);

        TEEC_Result res = delegate_key_ta(&ctx, custom_path, account, auth_token, delegate_password, password, delegate_key);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to delegate the key");
        else
            printf("Delegated key generated: %s\n", delegate_key);
    } else if (strcmp(cmd, "export_delegate_key") == 0) {
        printf("- Export a delegated key\n");
        char exported_key[HDKEYLEN];

        if (!delegate_password) {
            delegate_password = getpass("Enter delegate password: ");
            if (!delegate_password) {
                fprintf(stderr, "Failed to read delegate password\n");
                goto exit;
            }
        }

        TEEC_Result res = export_delegate_key_ta(&ctx, custom_path, account, delegate_password, exported_key);
        if (res != TEEC_SUCCESS)
            errx(1, "Failed to export the delegated key");
        else
            printf("Delegated key exported: %s\n", exported_key);
    } else {
        print_usage();
        errx(1, "Unknown command");
    }

    printf("\nWe're done, close and release TEE resources\n");
    terminate_tee_session(&ctx);
exit:
    if (mnemonic) {
        dogecoin_mem_zero(mnemonic, strlen(mnemonic));
    }
    if (shared_secret) {
        dogecoin_mem_zero(shared_secret, strlen(shared_secret));
    }
    if (password) {
        dogecoin_mem_zero(password, strlen(password));
    }
    if (delegate_password) {
        dogecoin_mem_zero(delegate_password, strlen(delegate_password));
    }
    if (yk) {
        yk_close_key(yk);
    }
    yk_release();
    return 0;
}
